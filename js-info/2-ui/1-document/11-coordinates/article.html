<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>article</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="coordinates">Coordinates</h1>
    <p>To move elements around we should be familiar with coordinates.</p>
    <p>Most JavaScript methods deal with one of two coordinate systems:</p>
    <ol type="1">
      <li>
        <strong>Relative to the window</strong> - similar to
        <code>position:fixed</code>, calculated from the window top/left edge.
        <ul>
          <li>
            we’ll denote these coordinates as <code>clientX/clientY</code>, the
            reasoning for such name will become clear later, when we study event
            properties.
          </li>
        </ul>
      </li>
      <li>
        <strong>Relative to the document</strong> - similar to
        <code>position:absolute</code> in the document root, calculated from the
        document top/left edge.
        <ul>
          <li>we’ll denote them <code>pageX/pageY</code>.</li>
        </ul>
      </li>
    </ol>
    <p>
      When the page is scrolled to the very beginning, so that the top/left
      corner of the window is exactly the document top/left corner, these
      coordinates equal each other. But after the document shifts,
      window-relative coordinates of elements change, as elements move across
      the window, while document-relative coordinates remain the same.
    </p>
    <p>
      On this picture we take a point in the document and demonstrate its
      coordinates before the scroll (left) and after it (right):
    </p>
    <p><img src="document-and-window-coordinates-scrolled.svg" /></p>
    <p>When the document scrolled:</p>
    <ul>
      <li>
        <code>pageY</code> - document-relative coordinate stayed the same, it’s
        counted from the document top (now scrolled out).
      </li>
      <li>
        <code>clientY</code> - window-relative coordinate did change (the arrow
        became shorter), as the same point became closer to window top.
      </li>
    </ul>
    <h2 id="element-coordinates-getboundingclientrect">
      Element coordinates: getBoundingClientRect
    </h2>
    <p>
      The method <code>elem.getBoundingClientRect()</code> returns window
      coordinates for a minimal rectangle that encloses <code>elem</code> as an
      object of built-in
      <a href="https://www.w3.org/TR/geometry-1/#domrect">DOMRect</a> class.
    </p>
    <p>Main <code>DOMRect</code> properties:</p>
    <ul>
      <li>
        <code>x/y</code> – X/Y-coordinates of the rectangle origin relative to
        window,
      </li>
      <li>
        <code>width/height</code> – width/height of the rectangle (can be
        negative).
      </li>
    </ul>
    <p>Additionally, there are derived properties:</p>
    <ul>
      <li>
        <code>top/bottom</code> – Y-coordinate for the top/bottom rectangle
        edge,
      </li>
      <li>
        <code>left/right</code> – X-coordinate for the left/right rectangle
        edge.
      </li>
    </ul>
    <pre
      class="online"
    ><code>For instance click this button to see its window coordinates:

&lt;p&gt;&lt;input id=&quot;brTest&quot; type=&quot;button&quot; value=&quot;Get coordinates using button.getBoundingClientRect() for this button&quot; onclick=&#39;showRect(this)&#39;/&gt;&lt;/p&gt;

&lt;script&gt;
function showRect(elem) {
  let r = elem.getBoundingClientRect();
  alert(`x:${r.x}
y:${r.y}
width:${r.width}
height:${r.height}
top:${r.top}
bottom:${r.bottom}
left:${r.left}
right:${r.right}
`);
}
&lt;/script&gt;

If you scroll the page and repeat, you&#39;ll notice that as window-relative button position changes, its window coordinates (`y/top/bottom` if you scroll vertically) change as well.</code></pre>
    <p>
      Here’s the picture of <code>elem.getBoundingClientRect()</code> output:
    </p>
    <p><img src="coordinates.svg" /></p>
    <p>
      As you can see, <code>x/y</code> and <code>width/height</code> fully
      describe the rectangle. Derived properties can be easily calculated from
      them:
    </p>
    <ul>
      <li><code>left = x</code></li>
      <li><code>top = y</code></li>
      <li><code>right = x + width</code></li>
      <li><code>bottom = y + height</code></li>
    </ul>
    <p>Please note:</p>
    <ul>
      <li>
        Coordinates may be decimal fractions, such as <code>10.5</code>. That’s
        normal, internally browser uses fractions in calculations. We don’t have
        to round them when setting to <code>style.left/top</code>.
      </li>
      <li>
        Coordinates may be negative. For instance, if the page is scrolled so
        that <code>elem</code> is now above the window, then
        <code>elem.getBoundingClientRect().top</code> is negative.
      </li>
    </ul>
    <p>
      ``<code>smart header="Why derived properties are needed? Why does</code
      >top/left<code>exist if there's</code>x/y<code
        >?" Mathematically, a rectangle is uniquely defined with its starting
        point</code
      >(x,y)<code>and the direction vector</code>(width,height)`. So the
      additional derived properties are for convenience.
    </p>
    <p>
      Technically it’s possible for <code>width/height</code> to be negative,
      that allows for “directed” rectangle, e.g. to represent mouse selection
      with properly marked start and end.
    </p>
    <p>
      Negative <code>width/height</code> values mean that the rectangle starts
      at its bottom-right corner and then “grows” left-upwards.
    </p>
    <p>
      Here’s a rectangle with negative <code>width</code> and
      <code>height</code> (e.g. <code>width=-200</code>,
      <code>height=-100</code>):
    </p>
    <p><img src="coordinates-negative.svg" /></p>
    <p>
      As you can see, <code>left/top</code> do not equal <code>x/y</code> in
      such case.
    </p>
    <p>
      In practice though, <code>elem.getBoundingClientRect()</code> always
      returns positive width/height, here we mention negative
      <code>width/height</code> only for you to understand why these seemingly
      duplicate properties are not actually duplicates.
    </p>
    <pre><code>
```warn header=&quot;Internet Explorer: no support for `x/y`&quot;
Internet Explorer doesn&#39;t support `x/y` properties for historical reasons.

So we can either make a polyfill (add getters in `DomRect.prototype`) or just use `top/left`, as they are always the same as `x/y` for positive `width/height`, in particular in the result of `elem.getBoundingClientRect()`.</code></pre>
    <p>
      ``<code
        >warn header="Coordinates right/bottom are different from CSS position
        properties" There are obvious similarities between window-relative
        coordinates and CSS</code
      >position:fixed`.
    </p>
    <p>
      But in CSS positioning, <code>right</code> property means the distance
      from the right edge, and <code>bottom</code> property means the distance
      from the bottom edge.
    </p>
    <p>
      If we just look at the picture above, we can see that in JavaScript it is
      not so. All window coordinates are counted from the top-left corner,
      including these ones. ```
    </p>
    <h2 id="elementfrompointx-y-elementfrompoint">
      elementFromPoint(x, y) [#elementFromPoint]
    </h2>
    <p>
      The call to <code>document.elementFromPoint(x, y)</code> returns the most
      nested element at window coordinates <code>(x, y)</code>.
    </p>
    <p>The syntax is:</p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> elem <span class="op">=</span> <span class="va">document</span>.<span class="at">elementFromPoint</span>(x<span class="op">,</span> y)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      For instance, the code below highlights and outputs the tag of the element
      that is now in the middle of the window:
    </p>
    <p>
      ```js run let centerX = document.documentElement.clientWidth / 2; let
      centerY = document.documentElement.clientHeight / 2;
    </p>
    <p>let elem = document.elementFromPoint(centerX, centerY);</p>
    <p>elem.style.background = “red”; alert(elem.tagName); ```</p>
    <p>
      As it uses window coordinates, the element may be different depending on
      the current scroll position.
    </p>
    <p>
      ```<code>warn header="For out-of-window coordinates the</code
      >elementFromPoint<code>returns</code>null<code>" The method</code
      >document.elementFromPoint(x,y)<code>only works if</code>(x,y)` are inside
      the visible area.
    </p>
    <p>
      If any of the coordinates is negative or exceeds the window width/height,
      then it returns <code>null</code>.
    </p>
    <p>Here’s a typical error that may occur if we don’t check for it:</p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">let</span> elem <span class="op">=</span> <span class="va">document</span>.<span class="at">elementFromPoint</span>(x<span class="op">,</span> y)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">// if the coordinates happen to be out of the window, then elem = null</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">*!*</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="va">elem</span>.<span class="va">style</span>.<span class="at">background</span> <span class="op">=</span> <span class="st">&#39;&#39;</span><span class="op">;</span> <span class="co">// Error!</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="op">*</span><span class="ss">/!</span><span class="sc">*</span></a></code></pre>
    </div>
    <pre><code>
## Using for &quot;fixed&quot; positioning

Most of time we need coordinates in order to position something.

To show something near an element, we can use `getBoundingClientRect` to get its coordinates, and then CSS `position` together with `left/top` (or `right/bottom`).

For instance, the function `createMessageUnder(elem, html)` below shows the message under `elem`:

```js
let elem = document.getElementById(&quot;coords-show-mark&quot;);

function createMessageUnder(elem, html) {
  // create message element
  let message = document.createElement(&#39;div&#39;);
  // better to use a css class for the style here
  message.style.cssText = &quot;position:fixed; color: red&quot;;

*!*
  // assign coordinates, don&#39;t forget &quot;px&quot;!
  let coords = elem.getBoundingClientRect();

  message.style.left = coords.left + &quot;px&quot;;
  message.style.top = coords.bottom + &quot;px&quot;;
*/!*

  message.innerHTML = html;

  return message;
}

// Usage:
// add it for 5 seconds in the document
let message = createMessageUnder(elem, &#39;Hello, world!&#39;);
document.body.append(message);
setTimeout(() =&gt; message.remove(), 5000);
```

```online
Click the button to run it:

&lt;button id=&quot;coords-show-mark&quot;&gt;Button with id=&quot;coords-show-mark&quot;, the message will appear under it&lt;/button&gt;
```

The code can be modified to show the message at the left, right, below, apply CSS animations to &quot;fade it in&quot; and so on. That&#39;s easy, as we have all the coordinates and sizes of the element.

But note the important detail: when the page is scrolled, the message flows away from the button.

The reason is obvious: the message element relies on `position:fixed`, so it remains at the same place of the window while the page scrolls away.

To change that, we need to use document-based coordinates and `position:absolute`.

## Document coordinates [#getCoords]

Document-relative coordinates start from the upper-left corner of the document, not the window.

In CSS, window coordinates correspond to `position:fixed`, while document coordinates are similar to `position:absolute` on top.

We can use `position:absolute` and `top/left` to put something at a certain place of the document, so that it remains there during a page scroll. But we need the right coordinates first.

There&#39;s no standard method to get the document coordinates of an element. But it&#39;s easy to write it.

The two coordinate systems are connected by the formula:
- `pageY` = `clientY` + height of the scrolled-out vertical part of the document.
- `pageX` = `clientX` + width of the scrolled-out horizontal part of the document.

The function `getCoords(elem)` will take window coordinates from `elem.getBoundingClientRect()` and add the current scroll to them:

```js
// get document coordinates of the element
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
```

If in the example above we used it with `position:absolute`, then the message would stay near the element on scroll.

The modified `createMessageUnder` function:

```js
function createMessageUnder(elem, html) {
  let message = document.createElement(&#39;div&#39;);
  message.style.cssText = &quot;*!*position:absolute*/!*; color: red&quot;;

  let coords = *!*getCoords(elem);*/!*

  message.style.left = coords.left + &quot;px&quot;;
  message.style.top = coords.bottom + &quot;px&quot;;

  message.innerHTML = html;

  return message;
}
```

## Summary

Any point on the page has coordinates:

1. Relative to the window -- `elem.getBoundingClientRect()`.
2. Relative to the document -- `elem.getBoundingClientRect()` plus the current page scroll.

Window coordinates are great to use with `position:fixed`, and document coordinates do well with `position:absolute`.

Both coordinate systems have their pros and cons; there are times we need one or the other one, just like CSS `position` `absolute` and `fixed`.</code></pre>
  </body>
</html>
