<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>article</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="file-and-filereader">File and FileReader</h1>
<p>A <a href="https://www.w3.org/TR/FileAPI/#dfn-file">File</a> object inherits from <code>Blob</code> and is extended with filesystem-related capabilities.</p>
<p>There are two ways to obtain it.</p>
<p>First, there’s a constructor, similar to <code>Blob</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">new</span> <span class="at">File</span>(fileParts<span class="op">,</span> fileName<span class="op">,</span> [options])<span class="op">;</span></a></code></pre></div>
<ul>
<li><strong><code>fileParts</code></strong> – is an array of Blob/BufferSource/String values.</li>
<li><strong><code>fileName</code></strong> – file name string.</li>
<li><strong><code>options</code></strong> – optional object:
<ul>
<li><strong><code>lastModified</code></strong> – the timestamp (integer date) of last modification.</li>
</ul></li>
</ul>
<p>Second, more often we get a file from <code>&lt;input type="file"&gt;</code> or drag’n’drop or other browser interfaces. In that case, the file gets this information from OS.</p>
<p>As <code>File</code> inherits from <code>Blob</code>, <code>File</code> objects have the same properties, plus:</p>
<ul>
<li><code>name</code> – the file name,</li>
<li><code>lastModified</code> – the timestamp of last modification.</li>
</ul>
<p>That’s how we can get a <code>File</code> object from <code>&lt;input type="file"&gt;</code>:</p>
<p>```html run <input type="file" onchange="showFile(this)" /></p>
<script>
  function showFile(input) {
    let file = input.files[0];

    alert(`File name: ${file.name}`); // e.g my.png
    alert(`Last modified: ${file.lastModified}`); // e.g 1552830408824
  }
</script>
<p>```</p>
<pre class="smart"><code>The input may select multiple files, so `input.files` is an array-like object with them. Here we have only one file, so we just take `input.files[0]`.</code></pre>
<h2 id="filereader">FileReader</h2>
<p><a href="https://www.w3.org/TR/FileAPI/#dfn-filereader">FileReader</a> is an object with the sole purpose of reading data from <code>Blob</code> (and hence <code>File</code> too) objects.</p>
<p>It delivers the data using events, as reading from disk may take time.</p>
<p>The constructor:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> reader <span class="op">=</span> <span class="kw">new</span> <span class="at">FileReader</span>()<span class="op">;</span> <span class="co">// no arguments</span></a></code></pre></div>
<p>The main methods:</p>
<ul>
<li><strong><code>readAsArrayBuffer(blob)</code></strong> – read the data in binary format <code>ArrayBuffer</code>.</li>
<li><strong><code>readAsText(blob, [encoding])</code></strong> – read the data as a text string with the given encoding (<code>utf-8</code> by default).</li>
<li><strong><code>readAsDataURL(blob)</code></strong> – read the binary data and encode it as base64 data url.</li>
<li><strong><code>abort()</code></strong> – cancel the operation.</li>
</ul>
<p>The choice of <code>read*</code> method depends on which format we prefer, how we’re going to use the data.</p>
<ul>
<li><code>readAsArrayBuffer</code> – for binary files, to do low-level binary operations. For high-level operations, like slicing, <code>File</code> inherits from <code>Blob</code>, so we can call them directly, without reading.</li>
<li><code>readAsText</code> – for text files, when we’d like to get a string.</li>
<li><code>readAsDataURL</code> – when we’d like to use this data in <code>src</code> for <code>img</code> or another tag. There’s an alternative to reading a file for that, as discussed in chapter <a href="info:blob" class="uri">info:blob</a>: <code>URL.createObjectURL(file)</code>.</li>
</ul>
<p>As the reading proceeds, there are events:</p>
<ul>
<li><code>loadstart</code> – loading started.</li>
<li><code>progress</code> – occurs during reading.</li>
<li><code>load</code> – no errors, reading complete.</li>
<li><code>abort</code> – <code>abort()</code> called.</li>
<li><code>error</code> – error has occurred.</li>
<li><code>loadend</code> – reading finished with either success or failure.</li>
</ul>
<p>When the reading is finished, we can access the result as:</p>
<ul>
<li><code>reader.result</code> is the result (if successful)</li>
<li><code>reader.error</code> is the error (if failed).</li>
</ul>
<p>The most widely used events are for sure <code>load</code> and <code>error</code>.</p>
<p>Here’s an example of reading a file:</p>
<p>```html run <input type="file" onchange="readFile(this)" /></p>
<script>
  function readFile(input) {
    let file = input.files[0];

    let reader = new FileReader();

    reader.readAsText(file);

    reader.onload = function () {
      console.log(reader.result);
    };

    reader.onerror = function () {
      console.log(reader.error);
    };
  }
</script>
<p>```</p>
<p>``<code>smart header="</code>FileReader<code>for blobs" As mentioned in the chapter &lt;info:blob&gt;,</code>FileReader` can read not just files, but any blobs.</p>
<p>We can use it to convert a blob to another format:</p>
<ul>
<li><code>readAsArrayBuffer(blob)</code> – to <code>ArrayBuffer</code>,</li>
<li><code>readAsText(blob, [encoding])</code> – to string (an alternative to <code>TextDecoder</code>),</li>
<li><code>readAsDataURL(blob)</code> – to base64 data url.</li>
</ul>
<pre><code>

```smart header=&quot;`FileReaderSync` is available inside Web Workers&quot;
For Web Workers, there also exists a synchronous variant of `FileReader`, called [FileReaderSync](https://www.w3.org/TR/FileAPI/#FileReaderSync).

Its reading methods `read*` do not generate events, but rather return a result, as regular functions do.

That&#39;s only inside a Web Worker though, because delays in synchronous calls, that are possible while reading from files, in Web Workers are less important. They do not affect the page.</code></pre>
<h2 id="summary">Summary</h2>
<p><code>File</code> objects inherit from <code>Blob</code>.</p>
<p>In addition to <code>Blob</code> methods and properties, <code>File</code> objects also have <code>name</code> and <code>lastModified</code> properties, plus the internal ability to read from filesystem. We usually get <code>File</code> objects from user input, like <code>&lt;input&gt;</code> or Drag’n’Drop events (<code>ondragend</code>).</p>
<p><code>FileReader</code> objects can read from a file or a blob, in one of three formats:</p>
<ul>
<li>String (<code>readAsText</code>).</li>
<li><code>ArrayBuffer</code> (<code>readAsArrayBuffer</code>).</li>
<li>Data url, base-64 encoded (<code>readAsDataURL</code>).</li>
</ul>
<p>In many cases though, we don’t have to read the file contents. Just as we did with blobs, we can create a short url with <code>URL.createObjectURL(file)</code> and assign it to <code>&lt;a&gt;</code> or <code>&lt;img&gt;</code>. This way the file can be downloaded or shown up as an image, as a part of canvas etc.</p>
<p>And if we’re going to send a <code>File</code> over a network, that’s also easy: network API like <code>XMLHttpRequest</code> or <code>fetch</code> natively accepts <code>File</code> objects.</p>
</body>
</html>
