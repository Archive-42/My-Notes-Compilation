<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>A-Very-Quick-Guide-To-Calculating-Big-O-Computational</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="a-very-quick-guide-to-calculating-big-o-computational-complexity">
      A Very Quick Guide To Calculating Big O Computational Complexity
    </h1>
    <p>Big O: big picture, broad strokes, not details</p>
    <hr />
    <h3 id="a-very-quick-guide-to-calculating-big-o-computational-complexity-1">
      A Very Quick Guide To Calculating Big O Computational Complexity
    </h3>
    <p><strong>Big O</strong>: big picture, broad strokes, not details</p>
    <p>For a more complete guide… checkout :</p>
    <p>
      <a
        href="https://medium.com/star-gazers/a-quick-guide-to-big-o-notation-memoization-tabulation-and-sorting-algorithms-by-example-803ff193c522"
        class="markup--anchor markup--mixtapeEmbed-anchor"
        title="https://medium.com/star-gazers/a-quick-guide-to-big-o-notation-memoization-tabulation-and-sorting-algorithms-by-example-803ff193c522"
        ><strong
          >A Quick Guide to Big-O Notation, Memoization, Tabulation, and Sorting
          Algorithms by Example</strong
        ><br />
        <em>Curating Complexity: A Guide to Big-O Notation</em>medium.com</a
      ><a
        href="https://medium.com/star-gazers/a-quick-guide-to-big-o-notation-memoization-tabulation-and-sorting-algorithms-by-example-803ff193c522"
        class="js-mixtapeImage mixtapeImage u-ignoreBlock"
      ></a>
    </p>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/800/0*lte81mEvgEPYXodB.png"
        class="graf-image"
      />
    </figure>
    <ul>
      <li>
        <span id="28b6"
          >way we analyze how efficient algorithms are without getting too mired
          in details</span
        >
      </li>
      <li>
        <span id="4141"
          >can model how much time any function will take given
          <code>n</code> inputs</span
        >
      </li>
      <li>
        <span id="9479"
          >interested in order of magnitude of number of the exact figure</span
        >
      </li>
      <li><span id="8fe1">O absorbs all fluff and n = biggest term</span></li>
      <li>
        <span id="a9c8"
          >Big O of <code>3x^2 +x + 1</code> = <code>O(n^2)</code></span
        >
      </li>
    </ul>
    <h3 id="time-complexity">Time Complexity</h3>
    <p>no loops or exit &amp; return = O(1)</p>
    <p>0 nested loops = <code>O(n)</code></p>
    <p>1 nested loops = <code>O(n^2)</code></p>
    <p>2 nested loops = <code>O(n^3)</code></p>
    <p>3 nested loops = <code>O(n^4)</code></p>
    <p>
      <strong>recursive</strong>: as you add more terms, increase in time as you
      add input diminishes<br />
      <strong>recursion</strong>: when you define something in terms of itself,
      a function that calls itself
    </p>
    <ul>
      <li>
        <span id="f455"
          >used because of ability to maintain state at diffferent levels of
          recursion</span
        >
      </li>
      <li><span id="f168">inherently carries large footprint</span></li>
      <li>
        <span id="5510">every time function called, you add call to stack</span>
      </li>
    </ul>
    <p>
      <strong>iterative</strong>: use loops instead of recursion (preferred)
    </p>
    <ul>
      <li>favor readability over performance</li>
    </ul>
    <p>
      <code>O(n log(n))</code> &amp; <code>O(log(n))</code> : dividing/halving
    </p>
    <ul>
      <li>
        <span id="4f7e"
          >if code employs recursion/divide-and-conquer strategy</span
        >
      </li>
      <li>
        <span id="d1cc">what power do i need to power my base to get n</span>
      </li>
    </ul>
    <h3 id="time-definitions">Time Definitions</h3>
    <ul>
      <li>
        <span id="9aad"
          ><strong>constant</strong>: does not scale with input, will take same
          amount of time</span
        >
      </li>
      <li>
        <span id="3a19"
          >for any input size n, constant time performs same number of
          operations every time</span
        >
      </li>
      <li>
        <span id="bf51"
          ><strong>logarithmic</strong>: increases number of operations it
          performs as logarithmic function of input size n</span
        >
      </li>
      <li>
        <span id="93d5"
          >function log n grows very slowly, so as n gets longer, number of
          operations the algorithm needs to perform doesn’t increase very
          much</span
        >
      </li>
      <li><span id="a2cf">halving</span></li>
      <li>
        <span id="46c0"
          ><strong>linear</strong>: increases number of operations it performs
          as linear function of input size n</span
        >
      </li>
      <li>
        <span id="5f16"
          >number of additional operations needed to perform grows in direct
          proportion to increase in input size n</span
        >
      </li>
      <li>
        <span id="ab93"
          ><strong>log-linear</strong>: increases number of operations it
          performs as log-linear function of input size n</span
        >
      </li>
      <li>
        <span id="0459"
          >looking over every element and doing work on each one</span
        >
      </li>
      <li>
        <span id="bd8a"
          ><strong>quadratic</strong>: increases number of operations it
          performs as quadratic function of input size n</span
        >
      </li>
      <li>
        <span id="dc41"
          ><strong>exponential</strong>: increases number of operations it
          performs as exponential function of input size n</span
        >
      </li>
      <li>
        <span id="71fc">number of nested loops increases as function of n</span>
      </li>
      <li>
        <span id="8253"
          ><strong>polynomial</strong>: as size of input increases,
          runtime/space used will grow at a faster rate</span
        >
      </li>
      <li>
        <span id="8827"
          ><strong>factorial</strong>: as size of input increases, runtime/space
          used will grow astronomically even with relatively small inputs</span
        >
      </li>
      <li>
        <span id="040c"
          ><strong>rate of growth</strong>: how fast a function grows with input
          size</span
        >
      </li>
    </ul>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/800/1*5t2u8n1uKhioIzZIXX2zbg.png"
        class="graf-image"
      />
    </figure>
    <h3 id="space-complexity">Space Complexity</h3>
    <ul>
      <li>
        <span id="403b"
          >How does the space usage scale/change as input gets very large?</span
        >
      </li>
      <li>
        <span id="5f20"
          >What auxiliary space does your algorithm use or is it in place
          (constant)?</span
        >
      </li>
      <li>
        <span id="b207"
          >Runtime stack space counts as part of space complexity unless told
          otherwise.</span
        >
      </li>
    </ul>
    <h3 id="sorting-algorithms">Sorting Algorithms</h3>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/800/1*HhXmG2cNdg8y4ZCCQGTyuQ.png"
        class="graf-image"
      />
    </figure>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/800/1*ULeXxVCDkF73GwhsxyM_2g.png"
        class="graf-image"
      />
    </figure>
    <h3 id="data-structures">Data Structures</h3>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/1200/1*hkZWlUgFyOSaLD5Uskv0tQ.png"
        class="graf-image"
      />
    </figure>
    <figure>
      <img
        src="https://cdn-images-1.medium.com/max/2560/1*COjzunj0-FsMJ0d7v7Z-6g.png"
        class="graf-image"
      />
    </figure>
    <p>For similar content check out my GitHub:</p>
    <p>
      <a
        href="https://github.com/bgoonz"
        class="markup--anchor markup--mixtapeEmbed-anchor"
        title="https://github.com/bgoonz"
        ><strong>bgoonz - Overview</strong><br />
        <em
          >Web Developer, Electrical Engineer https://bryanguner.medium.com/
          https://portfolio42.netlify.app/…</em
        >github.com</a
      ><a
        href="https://github.com/bgoonz"
        class="js-mixtapeImage mixtapeImage u-ignoreBlock"
      ></a>
    </p>
    <p>
      By
      <a href="https://medium.com/@bryanguner" class="p-author h-card"
        >Bryan Guner</a
      >
      on <a href="https://medium.com/p/eb1557e85fa3">May 19, 2021</a>.
    </p>
    <p>
      <a
        href="https://medium.com/@bryanguner/a-very-quick-guide-to-calculating-big-o-computational-complexity-eb1557e85fa3"
        class="p-canonical"
        >Canonical link</a
      >
    </p>
    <p>
      Exported from <a href="https://medium.com">Medium</a> on May 23, 2021.
    </p>
  </body>
</html>
